append(), prepend()
animate()
setInterval() <<>> clearInterval()

----------------------------------------------------------


변수 : "하나의 data를 저장 할 수 있는 저장공간"

var num=10;// 변수 num을 선언했다.자료형이 숫자(number)인 10으로 초기화했다.

num=100; // 변수num에 100을 대입한다. ( = 를 대입 연산자라고 한다.)

data의 종류

	number 숫자(정수, 실수)
	string 문자열
	object 객체
	null 공간만 있고 값이 없는 것.

	 예제

	 var v0=10;              number
	 var v1="jang"              string
 	 var v2=[1,2,3];               object
 	 var v3=new Date();               obejct


변수 : 특수문자안되고 숫자가 앞에오면 안되고 공란안되고 대문자 소문자 구분한다.


console.log();// ()값을 브라우저에 console에 표시
document.write();// document에 표시
alert();// 팝업창을 띄워라
promt(); // 입력창 "결과값을 반환"
confirm(); // 확인창  예, 아니오 "결과값을 반환"


------------------------------------------------------

논리 연산자 .....

AND 연산자 && ( 왼쪽 먼저 계산하는데 왼쪽과 오른쪽이 둘다 트루이면 트루값 리턴)

조건1 && 조건2  결과 값
true		 true	   	true
true     false    false
false    true     false
false    false    false

ex) if (아이디 =="manso1" && 비밀번호=="1111") { } ;

이런식으로 둘다 트루인 조건문을 만들어서 사용 가능하다!

								window

DOM              BOM                   내장객체


윈도우 객체의 실제 모습

window={
					innerWidth,  // 속성(property), field   얘
					alert=function(){ // 기능(매서드)        네
					},                                      들
					prompt=function(){                      은
					},                                      B
					confirm=function(){                     O
					},                                      M
					document={ // 객체   window.document.write();   얘
								write=function(){                         네
                                                          들
								},                                        은
								getElementById=function(){                 D
								},                                         O
					},                                               M

};

window.innerWidth; // 객체의 맴버에 접근하는 연산자는 .(점) 이다.
window.alert();
-------------------------------

parseInt("111"); 문자를 숫자로 바꿔라


대입 연산자 (=) " 오른쪽의 연산의 결과를 왼쪽 변수에 대입한다."
	ex ) var num=100+22+(222+200);

복합대입연산(할당연산자) "자신의 변수를 같은 값으로 변화"

	총쏘는 원리!

	+= num+=10;
	-= num-=10;
	*= num*=10;
	/= num/=10;
	%= num%=10;


---------------------------------------------------


var num=10;

왼쪽의 num 은 저장 공간을 의미한다.

num=num+10; // 10+10+10

오른쪽의 num은 참조를 의미한다.

-----------------------------------------------------

or(||) "하나이상의 조건이 true이면 결과 값이 true"
조건1 || 조건2 결과 값
true		 true		true
true		 false	true
false			true	true
false		false		false


** 연산자 실행순서 >>> 괄호 먼저 처리하는 것이 상식이다!

-------------------------------------------------------

삼항연산자

조건식 ? 조건true 일 때 실행 : 아닐 경우 실행

var num=10;

var result=num>10?1:0;

-----------------------------------------------------


조건 2개

if(){

}else{

}


조건 2개 이상, 여러개인 경우

if(){
}else if(조건){

}

switch 문

switch(key){

			case 0 : //key 값이 0이면
					실행문;;//처리,구현
			break; "break문 만나면 전체함수(로직)을 종료"

			case 1 : //key 값이 1이면
					실행문;;//처리,구현
			break; "break문 만나면 전체함수(로직)을 종료"

			case 2 : //key 값이 2이면
					실행문;;//처리,구현
			break; "break문 만나면 전체함수(로직)을 종료"

			case 3 : //key 값이 3이면
					실행문;;//처리,구현
			break; "break문 만나면 전체함수(로직)을 종료"

			default;
						기본처리문;
}


switch 문은 break문을 써주자!

---------------------------------------------------
* 리턴(return)이 하는 일은 크게 메소드 종료, 값의 반환 두 가지로 나뉩니다.

	값의 반환시 호출한 부분으로 인자로 받은 것을 반환합니다.

	그러나 대부분 리턴한다 → 값을 반환한다라는 의미로 많이 쓰입니다. 그 안에 종료의 의미도 포함 되어 있는 것이죠

	물론 return이 값의 반환 없이 메소드의 종료 역할을 할 때도 있습니다.

	return : 메소드 종료 의미와 값의 반환의 의미를 가진다.
---------------------------------------------------

==자바스크립트 선택자 ==(중요) >>>> 이벤트를 통해서 함수를 구현

이벤트 핸들러 >>> 이벤트를 구현 객체에 전달 해주는 역할
>>. 구조를 변경...

-----------------------------------------------------

(자바스크립트 선택자)

1. document.querySelector();

		.querySelector()는 CSS 선택자로 요소를 선택하게 해줍니다.
		주의할 점은 선택자에 해당하는 첫번째 요소만 선택한다는 것 입니다.
		아이디,클래스,태그 하나를 선택하게 해준다.

2. document.getElementById();

	HTML element의 아이디를 리턴(반환)한다.

3. document.getElementsByClassName();

	HTML element의 클래스 이름을 리턴(반환)한다.

4. document.getElementsByTagName();

 	HTML element의 태그 이름을 리턴(반환)한다.

5. document.querySelectorAll();

		.querySelectorAll()은 특정 CSS 선택자를 가진 모든 요소를 반환하는 속성입니다.

		ex) document.querySelectorAll('.abc') 클래스 값이 abc인 모든 요소를 리턴(반환)합니다.


			document.query.SelectorAll(".box")[0];
  		box클래스 중에서 첫번째 멤버를 선택한다.
			document.query.SelectorAll(".box")[1];
  		box클래스 중에서 두번쩨 멤버를 선택한다.

------------------------------------------------------
length >> 리스트의 총 갯수

document.querySelector(선택자); // 하나의 선택자를 지정하여 선택
document.querySelectorAll(선택자); // 지정한 선택자를 여러개 동시에 선택
document.querySelectorAll(선택자)[0]; // 지정한 선택자의 첫번째 맴버를 선택

document.getElementById('아이디');// 아이디
document.getElementsByClassName('클래스');// 클래스
document.getElementsByClassName('클래스')[0]; // 클래스의 첫번째 멤버 선택
document.getElementsByTagName('div');// 태그선택자이다. div 태그들 선택
document.getElementsByTagName('div')[0]; // 태그선택자이다. div태그중 첫번째 멤버 선택

document.getElementsByName('') // 폼태그 관련 네임 선택

---------------------------------------------------------------

선택자 >>> Selector
이벤트(mouse,keyboard,window) >> onClick, onMousedown, onKeyUp, onLoad
															>> 자바스크립트 객체에 연결 (이벤트 앞에 on이 붙은 것)


load << 윈도우 객체가 모두 로드되면(화면에 뿌려지면)
-------------------------------

getAttribute(''); 속성을 가져오는 것

get ~~~ 가져오는
set ~~~ 내가 만드는

객체={
		속성
}


form={
			method,
			name,
			id,
			action,
			submit=function{
			}
}

객체의 속성을 가져오는 함수 : getAttribute('');

ex ) form.getAttribute('method');

폼이라는 객체에서 method 속성을 가져온다.


---------------------------------

document.getElementsByName('') // 네임 선택

---------------------------------

자바스크립트는 구현하고자 하는 바로 밑에 설정하자.

---------------------------

click "마우스를 눌렀다 뗐을 때"
mousedown "마우스를 눌렀을 때"

--------------------------

선택자.innerHTML="태그";


선택자.innerHTML="태그" 태그를 선택자에 대입

선택자.innerHTML+="태그1"
선택자.innerHTML+="태그2" 	 태그 1, 2 를 선택자에 쌓음

선택자.innerHTML+="내용" 는 선택한 HTML태그 안에 내용을 누적한다.
---------------------------

함수(function) " 미리 어떤 기능을 사용하기 위해 만들어놓음"

function 함수명(){

}

함수는 이벤트(마우스,윈도우,키보드)를 통해 호출(call)한다.

------------------------------

do ~ while은 그냥 while에 비해 내용을 먼저 실행한 후에 조건을 비교합니다.
while은 조건을 먼저 비교한 후에 내용을 실행하고요.
그러니까 do ~ while은 내용이 최소 1번은 실행된다는 거죠.
while이나 for보다는 잘 쓰이지 않습니다.

--------------------------

--------------------------------------------

이벤트 효과는 마우스,window,키보드 를 통해 동작 >> 발생한다.

Mouse Event target(대상) >> event.target

마우스 관련 이벤트
click "마우스를 눌렀다 뗐을 때"
mousedown "눌렀을 때"
mouseup "눌렀다 뗐을 때"
mouseover "올렸을 때"
mouseout "벗어 났을 때"
mousemove "움직였을 때"
wheel

window
load "윈도우에 로드 되었을 때"
unload "윈도우에서 사라졌을 때"
scroll "윈도우 스크롤"
resize "윈도우 크기가 변할 때"

keyboard
keyup :"키보드키판을 뗐을 때" ajax, 총, 비밀번호 확인
keydown "키보드키판 눌렀을 때"

HTML 이벤트 핸들러는 사용하지 말도록 하자.
권장되지 않음. (on- 붙어서 HTML에 바로 쓰는 이벤트 핸들러 사용 x)

-----------------------------------------

함수(function) "미리 사용할 기능을 만든다."
function 함수명(){
		// 구현,처리,실행,로직...
		return 반환값 ; // 함수는 return을 만나면 종료.

}

--------------------------

선택자>>이벤트>>이벤트리스너(핸들러)>>함수

-----------------------------


이벤트 구현 >> 캡쳐링, 미러링

----------------------------

on은 이벤트를 전달해주는 하나의 키워드이다.

선택자.on이벤트명

----------------------------

function(){
				//return; 생략되어 있음.
}
----------------------------

.textContent ="텍스트"

.text >> 텍스트를 get ,set

//JQuery에서는 아래와 같이 쓰인다.

	.text(); // get
	.text("텍스트"); // set
	.css(''); get
	.css('',''); set
	.attr(); get
	.attr('',''); set

-----------------------------

1. 함수란 무엇인가?

	함수란 어떤 특정 작업을 수행하기 위해 필요한 일련의 구문들을 그룹화하기 위한 개념이다.
	만일 스크립트의 다른 부분에서 동일한 작업을 반복적으로 수행해야 한다면 (동일한 구문을 계속해서 반복 작성할
	필요 없이) 함수를 재사용할 수 있다.

2. 함수 선언 방법

	함수를 생성하기 위해서는 이름을 지정한 후 중괄호 안에 필요한 작업을 수행할 구문들을 작성해야 한다.
	이러한 과정을 '함수 선언(function declartion)'이라고 한다.

	ex)	function sayHello() { document.write('안녕하세요');
		함수키워드 함수이름  코드 블록(중괄호 사용)

3. 함수 호출 방법

	이미 선언된 함수가 존재한다면 그 함수가 중괄호로 둘러싸고 있는 코드를
	단 한줄의 코드를 이용하여 실행할 수 있다.
	이를 '함수를 호출한다'고 표현한다.

	ex)	sayHello();

4. 함수 매개변수 전달 방법

	간혹 함수는 자신의 작업을 수행하기 위해 추가적인 정보가 필요할 수도 있다.
	이런 경우에는 함수를 선언할 때 '매개변수(parameter)'를 전달하면 된다.
	매개변수는 함수 내에서는 변수와 동일하게 동작한다.

	ex)	function getArea(width, height) { return width * height; }

						 매개변수는 함수 내에서 변수처럼 사용한다.

	매개변수를 가진 함수를 호출할 때는 함수 이름 다음의 괄호 안에 값을 명시하면 된다.
	이 값들은 인수(arguments)라고 하며, 이를 통해 값이나 변수를 전달할 수 있다.


		값을 인수로 전달하기
		ex)	getArea(3, 5);


		변수를 인수로 전달하기
		ex) wallWidth = 3;
		    wallHeight = 5;
		    getArea(wallWidth, wallHeight);

5. 함수 익명함수 표현 방법

	자바스크립트 해석기가 표현식을 필요로 하는 곳에 함수를 전달하면 이 함수는 표현식으로 처리되며,
	이런 함수를 함수표현식(function expression)이라고 한다.

	함수 표현식을 사용할 때는 대부분 함수 이름을 생략하며, 이처럼 이름이 없는 함수를 익명 함수(anonymous function)
	라고 한다.

	아래 예제는 area라는 변수에 함수를 저장하는 코드이다.
	이렇게 하면 선언적 방식으로 정의된 함수와 마찬가지로 다른 코드에서 호출이 가능하다.

	var area = function(width, height) { return width * height;};

	var size = area(3, 4);


6. 지역 변수란?

	변수를 var 키워드를 이용하여 함수 내부에 선언하면 이 변수는 해당 함수 내부에서만 사용할 수 있다.
	이런 변수를 지역(Local) 변수 혹은 함수 수준(function-level) 변수라고 한다.
	이런 변수는 변수가 선언된 함수의 외부에서는 사용할 수 없다.

	지역 변수는 함수가 실행 중인 동안에만 메모리에 존재한다.

7. 전역 변수란?

	만일 함수의 바깥 부분에서 변수를 선언하면 이 변수는 스크림트의 어느 곳에서도 사용이 가능하다.
	이러한 변수를 전역(global) 변수라고 하며 전역 범위(global scope)를 가진다고 말한다.

	전역 변수는 웹 브라우저가 웹 페이지를 로드하고 있는 동안은 메모리에 지속적으로 보관되어 있다.
	따라서 지역 변수보다 더 많은 메모리를 사용하며, 변수 간 이름 충돌의 위험이 있다.
	이런 이유로 가능하면 지역 변수를 사용하도록 해야 한다.


* 전역 범위 내의 같은 이름의 변수들 : 이름이 충돌한다.
* 함수(서로 다른) 범위 내의 같은 이름의 변수들 : 이름의 충돌이 발생하지 않는다.

------------------------------------------------------------------------------

C >>> "같은 자료형의 data를 순서대로 그룹화"

java >>> 객체

배열 "리스트(목록), 다량의 data를 저장할 수 있는 변수이다."

new Array();// 객체 타입 자료형의 new 연산자를 통해서 생성

var arrInt=new Array(1,2,3,4,5); // 정수형 data를 요소(element)로 가지고 있는 배열 arrInt를 선언했다.

1. 배열의 요소는 0번지부터 시작된다.(인덱스가 0번부터 시작)
2. 전체 배열의 총 갯수는 총 index보다 항상 1 크다.
3. 반복문에 for과 함께 많이 사용.
4. 배열 생성
5. 배열의 이름은 배열의 주소 값을 저장한다.


var arrInt=new Array(1,2,3,4,5);

var arrInt2=[1,2,3,4,5];

-------------------------------------------------------------

- 함수란 무엇인가?

	미리 어떤 명령 처리하기 위한 코드 <<< 이벤트를 통해서


	*객체 구성(멤버): 속성,메서드,또 다른 객체
		**메서드 "객체 안에서 어떤 명령을 처리하기 위한 코드"

		window = {
					alert:function(){
					}
		}

		window.alert(); // 객체로 접근한 후에 메서드를 호출

		"함수는 <script></script> 안에서 구현한다."

- 함수 선언 방법

		function 함수명(){
						return 반환값;
		}
		function 함수명(매개변수){
						return
		}

-----------------------------------------------------
함수의 정의 부분에서 사용되는 변수를 매개변수(parameter)라 한답니다.
그걸 실제로 사용하는 부분의 값을 인수(argument)라 하지요.

자바스크립트의 약점 : 크로스 브라우징에 약하다.
-> 그래서 나온 것이 제이쿼리이다.
	제이쿼리에서 on이라는 키워드를 통해 이를 해소한다.
	단점은 하나밖에 구현을 못한다는 것.

---------------------------------------------------

isNaN(is Not A Number)

---------------------------------------------------


자바스크립트에는 블록 유효범위가 없다
다른 자바나 C 같은 언어와 달리 블록({}) 안에서
선언된 변수는 해당 블록이 닫힌 이후에도 접근할 수 있다.

다음 예제를 보자.

{
    var count = 10;
}
console.log(count);     // 10



for (var i=0; i<11; i++){}
console.log( i );       // 11


-------------------------------------------------------------------
함수 내부의 코드에서 변수를 사용하면 그 변수의 현재값을 찾기 위해 가장 먼저 함수 자신의 변수 스코프 객체에서 검색하게 된다.
-------------------------------------------------------------------

1. 객체란 무엇인가?

객체란 현실 세계에서 인지하는 물체에 대한 모델을 만들기 위해
변수와 함수를 그룹화 한 것을 말한다.
객체와 함수는 객체 내에서 새로운 이름으로 불린다.

2. 객체생성방법

축약식 표기법

	객체를 생성하는 가장 쉬우면서도 대중적인 방법이다.(객체를 생성하는 방법은 여러 가지가 있다.)

		ex ) var hotel = {
				name: 'Quay',
				rooms: 40,                 속성
				booked: 25,

				checkAvailability: function() {
					return this.rooms - this.booked;           메서드
				}


3. 객체생성방법2

축약식 표기법

	new와 객체 생성자는 빈 객체를 생성한다.
	그런 후에 객체에 속성과 메서드를 추가할 수 있다.

	var hotel = new Object();

	hotel.name = 'Quay';
	hotel.rooms = 40;	속성
	hotel.booked = 25;

	hotel.checkAvailability = function() {
	  return this.rooms - this.booked;	메서드
	};


4. 객체의 this란?

	함수가 객체의 내부에 선언되면 이 함수는 메서드가 된다.
	메서드 내에서 this 키워드는 메서드를 가지고 있는 객체를 가르킨다.


5. 브라우저객체모델(BOM) - 내장객체

	Browser Object Model

	현재 브라우저 창이나 탭을 표현하기 위한 객체들을 가지고 있다.
	이런 객체들은 주로 브라우저의 히스토리 목록이나 장치의 화면 등을 모델화한 것들이다.


6. 문서객체모델(DOM) - 내장객체

	Document Object Model

	현재 페이지를 표현하기 위해 사용되는 객체들이다.
	이들은 페이지 내의 각 요소들(과 개별 텍스트 섹션들)을
	위한 개별적인 객체들을 생성한다.


7. 전역자바스크립트 - 내장객체

	Global JavaScript Objects

	Global JavaScript Objects 는 자바스크립트 언어가 모델로서 생성해야 할 필요가 있는 것들을
	표현한다. 예를 들어 자바스크립트는 날짜와 시간을 처리하는 객체를 제공한다.


****************

자바스크립트에는 블록 유효범위가 없다
다른 자바나 C 같은 언어와 달리 블록({}) 안에서 선언된 변수는 해당 블록이 닫힌 이후에도 접근할 수 있다.

다음 예제를 보자.

{
    var count = 10;
}
console.log(count);     // 10



for (var i=0; i<11; i++){}
console.log( i );       // 11


**********************

함수 내부의 코드에서 변수를 사용하면 그 변수의 현재값을 찾기 위해
가장 먼저 함수 자신의 변수 스코프 객체에서 검색하게 된다.

-------------------------------------------------------------------
객체

-현실에서 인지하는 모든 것
-속성(property), 메서드(method), 또다른 객체(object)
-객체의 멤버(속성,메서드)
-속성 : 값(value)
-메서드 : 기능(action),행위

객체는 정리 정돈된 이름 상자이다.

var 객체 = {
		속성:값1,
		속성:값2,
		메서드:function(){
			//구현부
		}
};

객체.속성:
객체.메서드();
객체.객체.메서드();

---------------------------------------------------------------------------
보통은 이런식으로 함수를 선언한다.



function func(){}



근데 이미 알고있는 분들도있겠지만 함수는 이런식으로도 표현이 가능하다.



var func = function(){}



위쪽을 '함수 선언식' 아랫쪽을 '함수 표현식'이라고 말하는거같은데 이게 공식적인 용어인지는 잘 모르겠다.

여튼 어떤식으로 선언하든 호출은 동일하게 한다.


func();

결국 함수도 자바스크립트 내부적으로는 '변수'로 관리한다는 뜻이다.

변수와 함수가 내부적으로 동일하게 취급된다는 점이다.
이 말은 즉 함수와 변수의 이름이 같으면 서로 덮어쓴다는 거고 자바에서는 상상도 할 수 없는일이다.

--------------------------------------------------------------------------------

파싱과정에 소스 재정렬을 '호이스팅' 이라고 표현하기도한다.

단어뜻부터 끌어올린다는 뜻을 내포하고 있다.

자바스크립트는 사실 함수와 객체가 전부라고해도 무리는 없다고 생각한다.

그리고 객체는 var 변수에 저장하게되기때문에 자바스크립트를 코딩하면서 선언하게되는건 var 변수와 함수가 전부다.

그런데 자바스크립트의 파싱을 공부하면서 함수도 결국은 var 변수라는걸 알게되었고 var 변수의 파싱, 런타임에 대해서도 알게되었다.



이로써 자바스크립트가 돌아가는 큰틀에 대해서 어느정도 감을 잡았다고 할 수 있다.

---------------------------------------------------------------------------

자바스크립트에서 변수를 관리하는 메커니즘의 특징적인 부분을 3가지로 정리하면 다음과 같다.

1. 변수는 함수 단위로 관리한다.

2. 실행 시의 변수 검색은 렉시컬 영역(함수내 정의 환경)을 기준으로 한다.

3. 실행 시의 변수 검색은 변수 스코프 체인을 이용한다.

-----------------------------------------------

PHP 연관배열 -> 키값을 가져옴

---------------------------------------------

자바스크립트는 한번에 모든 소스를 컴파일하는 컴파일 언어가 아니라
한줄 한줄 실행하는 인터프리터 언어이다.
때문에 자바스크립트는 컴파일이라는 단어보다 파싱이라는 단어가
좀 더 정확한 단어라고 할수있다.
소스를 한번 파싱한 후 한줄씩 런타임으로 진행하게되는데
파싱단계에서 소스가 재정렬이 되게된다.

*이때 파싱과 런타임은 '함수' 단위로 실행되게된다.
좀 더 어려운 말을 쓰면 실행컨텍스트라고 하는데
함수라고 생각하면 이해가 쉽다. 그리고 최상위 레벨인 전역공간 역시
전역함수 내부에서 실행중이라고 생각하자.

---------------------------------------------

var func = function(){}

function func(){}



함수 선언은 위와 같은 2가지 문법이 있다.
-----------------------------------

자바스크립트는 파싱단계와 런타임단계로 나뉜다.

--------------------------------------

var가 없이 선언된 변수는 파싱단계에서는 그냥 넘어가고
런타임단계에서 '전역' 변수로 정의된다.

1.

function setName(_name){

var myname = _name;

}

setName("LichKing");

console.log(myname);

for(i=0,)

2.

function setName(_name){

myname = _name;

}

setName("LichKing");

console.log(myname);


1번 setName()의 name은 setName() 함수 내부에서만 유효하다.

때문에 전역단계에 myname이란 변수가 없으니 에러가 발생한다.

허나 2번 같은경우 setName()의 함수파싱단계에서 var변수나 함수선언 부분이 없으므로
그냥 지나가게되고 런타임시 myname이라는 변수가 '전역'레벨의 변수로 선언되고
_name의 값으로 초기화되게된다.
때문에 전역에서 myname을 호출하게되면 에러없이 "LichKing"이라는 문자열이 출력되게된다.

즉 *var 없이 변수를 선언하면 런타임시에 '전역' 변수로 선언된다.

파싱단계에서 재정렬되는것은 var변수와 함수선언이다.

--------------------------------

alert("선언 전 => " + num1);

var num1 = 5;

alert("선언 후 => " + num1);

위 코드에서 var num1 = 5; 를 보자
어떻게봐도 이건 var 변수 선언이다. 위에서 말한대로 파싱단계에서 선언부분이 최상단으로 올라오게되고
초기화부분까지 올라오는것은 아니기에 '5'가 아닌 'undefined'로 정의된다.

-----------------------------------

컴퓨터 프로그래밍에서 매개변수(영어: parameter 파라미터[*])란 변수의 특별한 한 종류로서,
함수 등과 같은 서브루틴[1]의 인풋으로 제공되는 여러 데이터 중 하나를 가리키기 위해 사용된다.
여기서 서브루틴의 인풋으로 제공되는 여러 데이터들을 전달인자(argument) 라고 부른다.

------------------------------

var x = "global";
function f () {
    alert(x);            //undefined 출력

    var x = "local";    //지역변수 "local" 선언

    alert(x);            //"local" 출력
}

함수내의 지역변수를 우선으로 한다.
함수내의 레벨에서 지역변수가 선언되어있으므로 호이스팅하지만,
초기화는 호이스팅하지 않는다. 따라서 var x 자체는 선언되어 있으나
값은 없는 상태이므로 첫번째 alert(x); 에서는 undefined가 나오고,
두번째 alert(x); 에서는 변수 x의 값이 "local"로 초기화 되었으므로
alert함수가 실행되고 모달창에 local이 나온다.

---------------------------

파싱(Parsing) = 분리 - 해석



컴파일러가 소스파일을 실행가능한 형태로 번역하기 전에 소스파일을 의미있는 단어의 단위로 잘라서 해석하는 작업.

(예를 들어 'printf("hello")'라는 구문이 있다면 기계어로 바꾸기 전에 printf와 (, ", hello, ", )로 단어와 기호들을 하나씩 나누는 것.

그 후에 컴파일. 이때 라이브러리 등을 참고)


컴파일(Compile) = 번역



프로그래밍 언어로 되어 있는 소스파일을 컴퓨터가 실행가능한 기계어로 바꾸는 작업.

소스파일(텍스트파일)을 바이너리 파일로 바꿔준다. 컴퓨터 언어 코드인 0과 1로 바꾸는 작업.

--------------------------

객체 지향 프로그래밍(OOP)에서 인스턴스(instance)는 해당 클래스의 구조로 컴퓨터 저장공간에서 할당된 실체를 의미한다.
여기서 클래스는 속성과 행위(메소드)로 구성된 일종의 설계도이다.
객체지향 프로그래밍(OOP)에서 객체는 클래스와 인스턴스를 포함한 개념이다.

----------------------------
http://jusungpark.tistory.com/32


--------------------

속성과 메서드를 사전에 정의하여 객체 생성하기

객체 생성자 표기법

함수를 이용하면 여러 개의 객체를 생성할 수 있다.
이때는 객체의 이름 대신 this 키워드를 사용한다.

	아래는 객체 생성자 표기법의 예시이다.

function.Hotel(name, rooms, booked) {
	this.name = name;
	this.rooms = rooms;
	this.booked = booked;
	this.checkAvailability = function() {
		return this.rooms - this.booked;
	};
}
var quayHotel = new Hotel('Quay', 40, 25);
var parkHotel = new Hotel('Park', 120, 77);

----------------------------

Avilability 유효성

-----------------------

객체의 멤버들

 1. property, 속성
 2. method 메소드, 기능,액션
 3. 객체

------------------------

배열도 객체다.

배열은 실제로 특별한 형식의 객체이다.
배열은 (객체와 마찬가지로) 서로 관련이 있는 키/값 쌍의 집합을 저장하지만
각 값의 키로는 인덱스 번호가 사용된다.

------------------------

전역자바스크립트(GJO)
String
Date
Array

offset >>> "위치" left,top,right,bottom

----------------------------

var setOut=setTimeout(함수,시간); // 함수를 시간 후에 한번
clearTimeout(setTimeout);//SetTimeout()함수 중지

var setInt=setInterval(함수, 시간);// 함수를 시간마다 실행
clearInterval(setInt); // setInterval() 함수 중지

--------------------------------

setTimeout(function(){},시간); //1000 >>> 1초

clearTimeout(setTimeout);

---------------------------------------

Date();

이 자바스크립트 내장 함수안에는 시간 정보가 다 담겨져 있다.

이를 이용하여 new Date();
이런식으로 시간 정보를 전부 담아줄 수 있다.

.getDate(); // 날짜(일)
.getFullYear(); // 년도
.getDay(); // 요일 (일요일 0)
.getMonth(); // 값에 +1 해주면 현재의 달이 된다.
.getHours(); // 시간
.getMinutes(); // 분
.getSeconds(); // 초

var currentTime=new Date();

var year=currentTime.getFullYear();

---------------------------------------

DOM 트리 정리

	브라우저는 웹 페이지를 로드할 때 해당 페이지에 대한 모델을 생성한다.
	이 모델을 DOM트리라고 부르며, 이 모델은 브라우저의 메모리에 저장된다.
	또한 이 모델은 네 종류의 노드로 구성된다.

노드(node)란?

	트리(tree) 구조에서 데이터의 상하위 계층을 나타내는 위치의 항목이다.
	각각의 노드는 메서드와 속성을 가진 객체이다.

문서 노드 정리

	트리의 최상위에는 문서 노드(document node)가 존재하며,
	이 노드는 전체 페이지를 표현한다.(또한, 브라우저 내에 document 객체로 구현되어 있다.)

요소 노드 정리

	DOM 트리에 접근하려면 일단 요소를 탐색해야 한다. 원하는 요소를 찾은 후에야
	비로소 필요에 따라 그 요소의 텍스트와 특성 노드에 접근할 수 있다.

	HTML 요소들은 HTML 페이지의 구조를 서술한다.

	텍스트나 특성에 접근하여 값을 변경하는 방법을 학습하기 이전에
	요소(element) 노드에 접근하는 메서드들을 먼저 학습해야 한다.

특성 노드 정리

	HTML 요소의 여는 태그에는 특성을 지정할 수 있으며, 이런 특성들은
	DOM 트리 내에서 특성(attribute) 노드로 표현된다.

텍스트 노드 정리

	일단, 요소 노드에 접근하면 해당 요소 내부의 텍스트에 접근할 수 있다.
	이 텍스트는 해당 요소의 텍스트 노드에 저장된다.

	텍스트 노드는 자식 노드를 가질 수 없다. 만일 요소가
	텍스트와 다른 자식 요소를 모두 가지고 있다면, 그 나머지 자식 요소들은
	텍스트 노드의 자식 노드가 아니라 해당 요소의 자식 노드로 표현된다.

	텍스트 노드는 DOM 트리 내에서 항상 새로운 노드로 표현되며, 그 하위에는
	더 이상의 노드가 존재하지 않음을 알 수 있다.

-------------------------------------------------

1. 요소에 접근하기

.getElementById();

	요소의 id 특성 값(페이지 내에서는 유일해야 한다.)를 이용한다.

.querySelector();

	CSS 선택자를 이용하며, 일치하는 요소들 중 첫 번째 요소를 리턴한다.

.getElementsByClassName();

	지정된 class 특성 값을 가지는 요소들을 모두 선택한다.

.getElementsByTagName();

	지정된 태그 이름을 가지는 요소들을 모두 선택한다.

.querySelectAll();

	지정된 CSS 선택자와 일치하는 요소들을 모두 선택한다.

.parentNode();

	현재 요소 노드의 부모 노드를 선택한다.(단 하나의 요소만 리턴한다.)

.previousSibling();

	현재 DOM 트리 내의 이전 형제 요소를 선택한다.

.nextSibling();

	현재 DOM 트리 내의 다음 형제 요소를 선택한다.

.firstChild();

	현재 요소의 첫 번째 자식 노드를 선택한다.

.lastChild();

	현재 요소의 마지막 자식 노드를 선택한다.


2. 요소 조작하기

.nodeValue();

	이 속성을 통해 텍스트 노드의 내용에 접근하거나 수정할 수 있다.

.innerHTML();

	모든 자식 요소와 텍스트 콘텐츠에 접근이 가능하다.

.createElement();

	새로운 요소를 생성한다.

.createTextNode()

	새로운 텍스트 노드를 생성한다.


.appendChild()

	생성된 요소를 DOM에 추가한다.


.removeChild()

	부모 요소로부터 요소를 제거한다.

.hasAttribute()
.getAttribute()
.setAttribute()
.removeAttribute()
